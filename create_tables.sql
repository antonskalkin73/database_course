/*
    Создаем таблицу заказчики
    int поле id является primary_key, а также при создании новой записи
    id генерируется автоматически. Важно: ключевое словао default 
    позволяет избежать в будущем ошибки при вставлении записи,
    у которой id уже заранее опредлен
    Ключевое слово unique означает уникальность
    (postgresql просто не даст создать новую запись,
    у которой значение поля phone_number будет совпадать
    с другой записью)
*/
CREATE TABLE Customer (
    id int unique PRIMARY KEY generated by DEFAULT as identity,
    full_name VARCHAR(255) not null,
    phone_number VARCHAR(255) unique not null,
    discount INT,
    order_count NUMERIC(6,2)
);

create table restaurant (
    id int unique PRIMARY KEY generated by DEFAULT as identity,
    name varchar(255) not null,
    address varchar(255) not null,
    work_hours varchar(255) not null
);

create table worker_type (
    id int unique PRIMARY KEY generated by DEFAULT as identity,
    category_name varchar(255) unique
);
create table worker (
    id int unique PRIMARY KEY generated by DEFAULT as identity,
    full_name varchar(255) not null,
    phone_number varchar(13) unique,
    workers_type_id int REFERENCES worker_type (id),
    restaurant_id int REFERENCES restaurant (id)
);
/*
    Здесь поле parent_product_type_id является внешним ключом
    для таблицы product_type. Да, внешний ключ, по факту,
    на свою де таблицу. Как это работает:
        Мы начинаем от меньшего к большему. Представим, что у нас
        есть какой-то определенный коктель, например молочный.
        Но также у нас есть и шоколадный и клубничный коктель.
        Все то коктели. Поэтому у них будет связь с общей для всех
        записю с названием
        'Коктели'. То есть каждый из наших коктелей будет
        ссылаться на запись 'Коктели'. А при выборке записи
        'Коктели' мы сможем пробежаться по id, которые
        записаны в поле parent_product_type_id, позволяя таким
        образом вывести все продукты (в нашем случае коктели),
        которые связаны с этой записью
*/
create table product_type (
    id int unique PRIMARY KEY generated by DEFAULT as identity,
    type_name VARCHAR(255) unique not null,
    age_limit BOOLEAN not null,
    parent_product_type_id int null REFERENCES product_type(id)
);

/*
    В этой таблице представлена простая свзяь many-to-one.
*/
create table product (
    id int unique PRIMARY KEY generated by DEFAULT as identity,
    name VARCHAR(255) UNIQUE not null,
    price NUMERIC(10,2) not null,
    product_type_id int REFERENCES product_type(id)
);
/*
    Поле datetime имеет тип данных timestamp. Он позволяет хранить в себе
    время, не привязанное к часовому поясу. Если необходимо хранить время,
    привязанное к часову поясу, нужно использовать timestamptz
*/
create table orders (
    id int unique PRIMARY KEY generated by DEFAULT as identity,
    datetime TIMESTAMP DEFAULT now(),
    status int not null,
    price NUMERIC(15,2) not null,
    restaurant_id int REFERENCES restaurant (id),
    customer_id int null REFERENCES customer (id),
    waiter_id int REFERENCES worker (id)
);
/*
    Ограничение primary key на внешний ключ поля deliverer_id позволяет
    реализовать связь one-to-one. Также мы используем внешний ключ для
    создания id записи
*/
create table delivery (
    order_id int REFERENCES worker (id),
    address text not null,
    datetime TIMESTAMP DEFAULT now(),
    deliverer_id int primary key REFERENCES orders (id)
);
/*
    Вспомогательная таблица для связи many-to-many
*/
create table order_menu (
    order_id int REFERENCES orders (id),
    menu_id int REFERENCES product (id),
    count int not null,
    price NUMERIC(10,2) not null,
    cool_id int REFERENCES worker (id)
);
